{"version":3,"sources":["di.ts","experiments.ts","index.ts"],"names":[],"mappings":";AAmBA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAlBA,MAAM,EAAI,IAAI,IAER,EAAS,GAAc,EAAE,WAAW,GAEpC,EAAgB,MACjB,IACA,MAAM,IACN,IAAI,GACJ,KAAK,IACL,UAAU,EAAG,IASlB,SAAgB,EAAU,GACjB,MAAA,CAAC,EAAQ,IACd,OAAO,eAAe,EAAQ,EAAM,CAClC,IAAK,IAAM,QAAA,IAAI,KAVR,QAAA,IAAU,CAAA,GAAwB,EAAE,IAAI,EAAU,KAClD,QAAA,IAAU,CAAA,KAAgC,EAAE,IAAI,EAAU,KAC1D,QAAA,IAAM,EAAI,EAAkB,EAAO,EAAU,KACxD,QAAA,IAAI,GAAK,QAAA,IAAI,GAAK,EAAE,IAAI,EAAM,IAAI,GAAK,IAAI,IAChC,QAAA,MAAQ,KAAM,EAAE,SAChB,QAAA,OAAa,CAAA,GAAqB,EAAE,OAAO,EAAU,KAElE,QAAA,OAAA;;ACCA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IApBA,MAAA,EAAA,QAAA,QAKA,SAAgB,KAAa,GACpB,MAAA,IACF,KAMG,MAAA,EAAI,EAAE,GAAG,MACf,EAAE,GAAG,MAAQ,YAAY,GAChB,MAAA,IAAM,EAAE,MAAM,KAAM,EAAd,CAAoB,EAAG,IAAI,GAAK,EAAA,IAAI,OAKvD,SAAgB,KAAS,GAChB,MAAA,IACF,KAMG,MAAA,EAAI,EAAE,GAAG,MACf,EAAE,GAAG,MAAQ,WACJ,OAAA,EAAE,MACP,KACA,EAAG,IAAI,GAAK,EAAA,IAAI,OA3BxB,QAAA,OAAA,EAeA,QAAA,GAAA;;ACnBA,aAAA,SAAA,EAAA,GAAA,IAAA,IAAA,KAAA,EAAA,QAAA,eAAA,KAAA,QAAA,GAAA,EAAA,IAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IADA,EAAA,QAAA,SACA,EAAA,QAAA","file":"index.js","sourceRoot":"../src","sourcesContent":["export type ObjectType<T> = new (...args: unknown[]) => T;\nconst C = new Map();\n\nconst ascii = (a: string) => a.charCodeAt(0);\n\nconst toHashKey = <T>(c: ObjectType<T>) =>\n  `${c}`\n    .split('')\n    .map(ascii)\n    .join('')\n    .substring(0, 50);\n\nexport const get = <T>(c: ObjectType<T>): T => C.get(toHashKey(c));\nexport const has = <T>(c: ObjectType<T>): boolean => !!C.has(toHashKey(c));\nexport const set = <T>(c: ObjectType<T>, hash = toHashKey(c)): T =>\n  has(c) ? get(c) : C.set(hash, new c()).get(hash);\nexport const clear = () => C.clear();\nexport const remove = <T>(c: ObjectType<T>) => C.delete(toHashKey(c));\n\nexport function Inject<T>(clazz: ObjectType<T>): PropertyDecorator {\n  return (target, name: string) =>\n    Object.defineProperty(target, name, {\n      get: () => set(clazz)\n    });\n}\n","import { ObjectType, set } from './di';\n\nexport type Reader<T, K> = (d?: T) => K;\nexport type PrivateReader<T, K> = (d: NonNullable<T>) => K;\n\nexport function Reader<T>(...di: ObjectType<unknown>[]): MethodDecorator {\n  return (\n    ...a: [\n      Record<string, unknown>,\n      string | symbol,\n      TypedPropertyDescriptor<unknown>\n    ]\n  ) => {\n    const o = a[2].value as Function;\n    a[2].value = function(...args: unknown[]) {\n      return () => o.apply(this, args)(di.map(p => set(p)));\n    };\n  };\n}\n\nexport function DI<T>(...di: ObjectType<T>[]): MethodDecorator {\n  return (\n    ...a: [\n      Record<string, unknown>,\n      string | symbol,\n      TypedPropertyDescriptor<unknown>\n    ]\n  ) => {\n    const m = a[2].value as Function;\n    a[2].value = function() {\n      return m.apply(\n        this,\n        di.map(p => set(p))\n      );\n    };\n  };\n}\n","export * from './di';\nexport * from './experiments';\n"]}