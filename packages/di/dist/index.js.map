{"version":3,"sources":["di.ts","decorators.ts","index.ts"],"names":[],"mappings":";AAyBa,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAvBb,MAAa,GAAb,QAAA,eAAA,EAIA,IAAI,EAAI,IAAI,QAEZ,MAAM,EAAiB,GACrB,EAAE,WAAa,EAAE,UAAU,YAAc,IAAI,EAAM,EAGrD,SAAgB,EAAO,GACd,OAAA,EAAE,IAAI,GAGf,SAAgB,EAAO,GACd,QAAE,EAAE,IAAI,GAGjB,SAAgB,EAAO,EAAkB,GAChC,OAAA,EAAE,IAAI,GAAK,EAAE,IAAI,GAAK,EAAE,IAAI,GAAQ,EAAG,EAAW,IAAI,IAAI,GAAQ,GAT3E,QAAA,IAAA,EAIA,QAAA,IAAA,EAIA,QAAA,IAAA,EAIa,QAAA,OAAa,CAAA,GAAqB,EAAE,OAAO,IAC3C,QAAA,MAAQ,KAAO,EAAI,IAAI;;AC6DvB,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IArFb,QAAA,uBAEA,MAAA,EAAA,QAAA,QASA,SAAgB,KAAa,GACpB,MAAA,IAAI,KACH,MAAA,EAAI,EAAE,GAAG,MACf,EAAE,GAAG,MAAQ,YAAY,GAChB,MAAA,IAAM,EAAE,MAAM,KAAM,EAAd,CAAoB,EAAG,IAAI,GAAK,EAAA,IAAI,OAKvD,SAAgB,KAAS,GAChB,MAAA,IAAI,KACH,MAAA,EAAI,EAAE,GAAG,MACf,EAAE,GAAG,MAAQ,WACJ,OAAA,EAAE,MACP,KACA,EAAG,IAAI,GAAK,EAAA,IAAI,OAfxB,QAAA,OAAA,EASA,QAAA,GAAA,EAYA,MAAM,EAAkB,SAKxB,SAAgB,EAAU,GACjB,MAAA,CACL,EACA,EACA,EACA,EAA+B,QAAQ,eACrC,EACA,EACA,IACG,MAEL,EAAO,KAAK,CAAC,EAAO,IACpB,QAAQ,eAAe,EAAiB,EAAQ,EAAQ,GACxD,OAAO,eAAe,EAAQ,EAAM,CAClC,IAAK,IAAM,EAAA,IAAI,MAdrB,QAAA,OAAA,EAmBa,QAAA,WAAiB,CAAA,GAAgC,CAG5D,EACA,EAA+B,QAAQ,eACrC,EACA,IACG,MAEL,EAAA,IAAI,EAAM,GACH,cAAc,EACnB,eAAe,GACR,IAAA,MAAO,EAAO,KAAe,EAChC,EAAK,GAAS,EAAA,IAAI,GAEd,SAAG,OAYf,MAAM,EAAc,IAAwB,GAAK,IAAI,IAAI,GAAK,EAAA,IAAI,IAErD,QAAA,OAAS,EAAI,EAA4B,KAGpD,IAEA,cAAc,EACZ,eAAe,GACb,EAAQ,EAAE,SACV,EAAQ,EAAE,WACJ,SAAG;;AC9Ff,aAAA,SAAA,EAAA,GAAA,IAAA,IAAA,KAAA,EAAA,QAAA,eAAA,KAAA,QAAA,GAAA,EAAA,IAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IADA,EAAA,QAAA,SACA,EAAA,QAAA","file":"index.js","sourceRoot":"../src","sourcesContent":["export type ObjectType<T> = new (...args: unknown[]) => T;\n\nexport class InjectionToken<T> {}\n\nexport type ObjectUnion<T> = T | ObjectType<T> | InjectionToken<T>;\n\nlet C = new WeakMap();\n\nconst safeHandle = <T>(c: ObjectType<T>) =>\n  c.prototype && c.prototype.constructor ? new c() : c;\n\nexport function get<T>(c: ObjectUnion<T>): T;\nexport function get<T>(c: ObjectType<T>): T {\n  return C.get(c);\n}\nexport function has<T>(c: ObjectUnion<T>): boolean;\nexport function has<T>(c: ObjectType<T>): boolean {\n  return !!C.has(c);\n}\nexport function set<T>(c: T | ObjectType<T>, k?: ObjectUnion<T>): T;\nexport function set<T>(c: ObjectType<T>, k?: ObjectUnion<T>): T {\n  return C.has(c) ? C.get(c) : C.set(k ? k : c, safeHandle(c)).get(k ? k : c);\n}\n\nexport const remove = <T>(c: ObjectType<T>) => C.delete(c);\nexport const clear = () => (C = new WeakMap());\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport '@abraham/reflection';\n\nimport { ObjectType, ObjectUnion, set } from './di';\n\nexport type Reader<T, K> = (d?: T) => K;\nexport type PrivateReader<T, K> = (d: NonNullable<T>) => K;\ntype MethodDecoratorArguments = [\n  Record<string, unknown>,\n  string | symbol,\n  TypedPropertyDescriptor<unknown>\n];\nexport function Reader<T>(...di: ObjectType<unknown>[]): MethodDecorator {\n  return (...a: MethodDecoratorArguments) => {\n    const o = a[2].value as Function;\n    a[2].value = function(...args: unknown[]) {\n      return () => o.apply(this, args)(di.map(p => set(p)));\n    };\n  };\n}\n\nexport function DI<T>(...di: ObjectType<T>[]): MethodDecorator {\n  return (...a: MethodDecoratorArguments) => {\n    const m = a[2].value as Function;\n    a[2].value = function() {\n      return m.apply(\n        this,\n        di.map(p => set(p))\n      );\n    };\n  };\n}\n\nconst ReflectionParam = Symbol();\ntype ReflectionParam<T> = [number, ObjectUnion<T>];\n\nexport function Inject<T>(identifier: ObjectUnion<T>): any;\nexport function Inject<T>(identifier: ObjectUnion<T>): PropertyDecorator;\nexport function Inject<T>(identifier: ObjectType<T>): PropertyDecorator {\n  return (\n    target,\n    name: string,\n    index?: number,\n    params: ReflectionParam<T>[] = Reflect.getOwnMetadata(\n      ReflectionParam,\n      target,\n      name\n    ) || []\n  ) => {\n    params.push([index, identifier]);\n    Reflect.defineMetadata(ReflectionParam, params, target, name);\n    Object.defineProperty(target, name, {\n      get: () => set(identifier)\n    });\n  };\n}\n\nexport const Injectable = <T>(token?: ObjectUnion<T>): any => <\n  K extends new (...args: any[]) => {}\n>(\n  Base: K,\n  params: ReflectionParam<T>[] = Reflect.getOwnMetadata(\n    ReflectionParam,\n    Base\n  ) || []\n) => {\n  set(Base, token);\n  return class extends Base {\n    constructor(...args: any[]) {\n      for (const [index, identifier] of params) {\n        args[index] = set(identifier);\n      }\n      super(...args);\n    }\n  };\n};\n\nexport interface ModuleWithProviders<T = {}> {\n  providers?: ObjectType<T>[];\n  imports?: ObjectType<T>[];\n}\n\ntype Constructor<T = {}> = new (...args: any[]) => T;\n\nconst setDeps = <T>(i: ObjectType<T>[]) => (i || []).map(p => set(p));\n\nexport const Module = <T>(o: ModuleWithProviders<T> = {}) => <\n  TBase extends Constructor\n>(\n  Base: TBase\n) =>\n  class extends Base {\n    constructor(...args: any[]) {\n      setDeps(o.imports);\n      setDeps(o.providers);\n      super(...args);\n    }\n  };\n","export * from './di';\nexport * from './decorators';\n"]}