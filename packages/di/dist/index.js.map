{"version":3,"sources":["index.ts"],"names":[],"mappings":";AAyHa,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IArGb,MAAa,GAAb,QAAA,eAAA,EAEA,IAAI,EAAI,IAAI,QAEZ,MAAM,EAAiB,GACrB,EAAE,WAAa,EAAE,UAAU,YAAc,IAAI,EAAM,EAGrD,SAAgB,EAAO,GACd,OAAA,EAAE,IAAI,GAGf,SAAgB,EAAO,GACd,QAAE,EAAE,IAAI,GAGjB,SAAgB,EAAO,EAAkB,GAChC,OAAA,EAAE,IAAI,GAAK,EAAE,IAAI,GAAK,EAAE,IAAI,GAAQ,EAAG,EAAW,IAAI,IAAI,GAAQ,GAI3E,SAAgB,EAAU,GACjB,OAAA,EAAE,OAAO,GAQlB,SAAgB,KAAa,GACpB,MAAA,KAAS,CAAA,CAAA,MACR,MAAA,EAAI,EAAK,MACf,EAAK,MAAQ,YAAY,GAChB,MAAA,IAAM,EAAE,MAAM,KAAM,EAAd,CAAoB,EAAG,IAAI,GAAK,EAAI,OAKvD,SAAS,EAAgB,EAA+B,IACjD,IAAA,MAAM,KAAY,EACjB,EAAS,IACX,EAAI,EAAS,IAAK,EAAS,SAE3B,EAAI,GApCV,QAAA,IAAA,EAIA,QAAA,IAAA,EAIA,QAAA,IAAA,EAKA,QAAA,OAAA,EAIa,QAAA,MAAQ,WACnB,EAAI,IAAI,SAIV,QAAA,OAAA,EAmBa,QAAA,OAAS,EAAI,EAA4B,KAGpD,IAEA,cAAc,EACZ,eAAe,GACb,EAAa,EAAE,SACf,EAAa,EAAE,WACT,SAAG,OAIf,MAAM,EAAO,IAAI,QAEX,EAAe,CACnB,EACA,EACA,IAEA,OAAO,eAAe,EAAQ,EAAM,CAClC,IAAK,IAAM,EAAI,GACf,cAAc,IAKlB,SAAgB,EAAU,GACjB,MAAA,CACL,EACA,EACA,EACA,EAAS,EAAK,IAAI,IAAW,MAEzB,EACF,EAAa,EAAQ,EAAM,IAE3B,EAAO,KAAK,CAAC,EAAO,IACpB,EAAK,IAAI,EAAQ,KAXvB,QAAA,OAAA,EAyBa,QAAA,WAAa,GACtB,UAAA,GAAyC,CAAE,UAAW,MACrD,CACH,EACA,EAAa,EAAK,IAAI,IAAS,MAE/B,cAAc,EACZ,eAAe,GACT,IAAC,EAAK,OAAQ,CAChB,EAAa,GACP,MAAA,EACH,QAAO,aACL,QAAO,YAAgB,oBAAqB,IAG/C,GACG,IAAA,MAAO,EAAO,KAAe,EAAS,UACzC,EAAa,EAAM,EAAO,GAEvB,IAAA,MAAO,EAAO,KAAe,EAChC,EAAa,EAAM,EAAO,GAGxB,SAAG","file":"index.js","sourceRoot":"../src","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n\nexport type ObjectType<T = {}> = new (...args: any[]) => T;\nexport type PrivateReader<T, K> = (d: NonNullable<T>) => K;\nexport type MethodDecoratorArguments = [\n  Record<string, unknown>,\n  string | symbol,\n  TypedPropertyDescriptor<unknown>\n];\nexport type ObjectUnion<T = {}> = T | ObjectType<T> | InjectionToken<T>;\n\ninterface Provider<T = {}> {\n  provide: ObjectUnion<T>;\n  use: ObjectUnion<T>;\n}\n\nexport interface ModuleWithProviders<T = {}> {\n  providers?: Provider<T>[] | T;\n  imports?: ObjectType<T>[];\n}\nexport class InjectionToken<T> {}\n\nlet C = new WeakMap();\n\nconst safeHandle = <T>(c: ObjectType<T>) =>\n  c.prototype && c.prototype.constructor ? new c() : c;\n\nexport function get<T>(c: ObjectUnion<T>): T;\nexport function get<T>(c: ObjectType<T>): T {\n  return C.get(c);\n}\nexport function has<T>(c: ObjectUnion<T>): boolean;\nexport function has<T>(c: ObjectType<T>): boolean {\n  return !!C.has(c);\n}\nexport function set<T>(c: T | ObjectType<T>, k?: ObjectUnion<T>): T;\nexport function set<T>(c: ObjectType<T>, k?: ObjectUnion<T>): T {\n  return C.has(c) ? C.get(c) : C.set(k ? k : c, safeHandle(c)).get(k ? k : c);\n}\n\nexport function remove<T>(c: T | ObjectType<T>): boolean;\nexport function remove<T>(c: ObjectType<T>) {\n  return C.delete(c);\n}\n\nexport const clear = function() {\n  C = new WeakMap();\n};\n\nexport type Reader<T, K> = (d?: T) => K;\nexport function Reader<T>(...di: ObjectType<unknown>[]): MethodDecorator {\n  return (...[, , desc]: MethodDecoratorArguments) => {\n    const o = desc.value as Function;\n    desc.value = function(...args: unknown[]) {\n      return () => o.apply(this, args)(di.map(p => set(p)));\n    };\n  };\n}\n\nfunction setProviders<T>(providers: Provider<T>[] | T = []) {\n  for (const provider of providers as Provider<T>[]) {\n    if (provider.use) {\n      set(provider.use, provider.provide);\n    } else {\n      set(provider);\n    }\n  }\n}\n\nexport const Module = <T>(o: ModuleWithProviders<T> = {}) => <\n  TBase extends ObjectType\n>(\n  Base: TBase\n) =>\n  class extends Base {\n    constructor(...args: any[]) {\n      setProviders(o.imports);\n      setProviders(o.providers);\n      super(...args);\n    }\n  };\n\nconst meta = new WeakMap<ObjectUnion, Array<ObjectUnion>>();\n\nconst defineGetter = (\n  target: ObjectUnion,\n  name: string | number,\n  identifier: ObjectUnion\n) =>\n  Object.defineProperty(target, name, {\n    get: () => set(identifier),\n    configurable: true\n  });\n\nexport function Inject<T>(identifier: ObjectUnion<T>): any;\nexport function Inject<T>(identifier: ObjectUnion<T>): PropertyDecorator;\nexport function Inject<T>(identifier: ObjectType<T>): PropertyDecorator {\n  return (\n    target,\n    name: string,\n    index?: number,\n    params = meta.get(target) || []\n  ) => {\n    if (name) {\n      defineGetter(target, name, identifier);\n    } else {\n      params.push([index, identifier]);\n      meta.set(target, params);\n    }\n  };\n}\n\n// const defineMetaInjectors = (\n//   args: any[],\n//   metadata: [number, ObjectUnion][]\n// ) => {\n//   for (const [index, identifier] of metadata) {\n//     defineGetter(args, index, identifier);\n//   }\n// };\n\nexport const Injectable = (\n  { providers }: { providers: Provider[] } = { providers: [] }\n) => <K extends new (...args: any[]) => {}>(\n  Base: K,\n  metaParams = meta.get(Base) || []\n) =>\n  class extends Base {\n    constructor(...args: any[]) {\n      if (!args.length) {\n        setProviders(providers);\n        const metadata =\n          (Reflect['getMetadata'] &&\n            (Reflect['getMetadata']('design:paramtypes', Base) as ObjectUnion<\n              K\n            >[])) ||\n          [];\n        for (const [index, identifier] of metadata.entries()) {\n          defineGetter(args, index, identifier);\n        }\n        for (const [index, identifier] of metaParams) {\n          defineGetter(args, index, identifier);\n        }\n      }\n      super(...args);\n    }\n  };\n"]}